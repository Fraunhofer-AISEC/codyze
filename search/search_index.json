{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Codyze/","title":"Documentation","text":"<p>Info</p> <p>Codyze is currently being redesigned. For the documentation for the last stable version of Codyze using the MARK specification language, please look here .</p> <p>Security is hard and implementing it correctly is even harder. Luckily, there are well-established and battle-proven libraries available that do the heavy lifting of security functions such as authentication, logging or encryption. But even when using these libraries in application code, developers run the risk of making subtle errors which may undermine the security of their application. This is where Codyze helps. By integrating it into an IDE or CI pipeline, developers can analyze their source code while programming and check if they are using libraries in a correct or in an insecure way.</p>"},{"location":"Codyze/#how-does-it-work","title":"How does it work?","text":"<p>In contrast to many other static analysis tools, Codyze directly analyzes the source code and does not require a compiler tool-chain. It can thus even analyze incomplete source code and tolerate small syntax errors.</p> <p>Codyze is based on a \"Code Property Graph\", which represents the source code as a graph and adds semantic information to support the analysis. This representation can be used in two ways:</p> <ol> <li>as a fully automated tool, integrated into your CI or IDE</li> <li>as a database that can be manually explored using a simple query language  </li> </ol> <p> </p>"},{"location":"Codyze/#why-codyze","title":"Why Codyze?","text":"<p>Codyze checks source code for the correct usage of libraries. It is an addition to generic static analysis tools such as Sonarqube, Frama-C, or the Checker Framework and specifically verifies that libraries are used as originally intended by their developers. </p> <p>Library developers write rules for their library in specification languages supported by Codyze.</p> <p>Developers verify their code against rules of modelled libraries using Codyze.</p> <p>Integrators of open source components may want to verify these components using the automated analysis of Codyze or by manually searching the code for critical patterns.</p>"},{"location":"Codyze/why-v3/","title":"Redesign of Codyze","text":"<p>The goal of the redesign is to make Codyze more maintainable and easier extendable. This introduced a lot of changes compared to the legacy version.</p> <p>The core functionalities of Codyze were separated from the executable part which makes it possible to use Codyze as a library.</p> <p>We introduced the concept of Executors which are responsible for evaluating rules of a specific specification language. Through Executors, Codyze can verify rules written in different specification languages and utilize their advantages as long as there is an Executor for them.</p> <p>We are also working on a new specification language Coko which comes with Codyze.</p> <p>Additionally, we reorganized the code in Codyze to be able to handle multiple projects with their own configurations with only one Codyze instance. This, for example, allows switching between projects in an IDE without losing the context of any analysis and should better support LSP mode.</p>"},{"location":"Coko/","title":"What is Coko?","text":"<p>Codyze provides a built-in domain specific language, Coko, which can be used to define policies for Codyze.</p>"},{"location":"Coko/#structure-of-policies","title":"Structure of Policies","text":"<p>Coko policies can be split into two parts:</p> <ul> <li>Modelling the API through classes and functions.</li> <li>Writing rules that describe the expected usage of the modelled API.</li> </ul> <p>When modeling a library, you will typically start by describing its classes or functions and then write rules.</p>"},{"location":"Coko/#structure-of-coko","title":"Structure of Coko","text":"<p>Coko is defined as a custom Kotlin scripting language. It serves as an API to write source code queries in a declarative way. The rules written in Coko are executed to construct the queries for the used backend.</p> <p>The concept of Coko is that the API is modelled through classes and functions. These classes and functions are used to declare rules, which Codyze then evaluates.  Coko is, therefore, in its concept more similar to a domain specific language and only uses the Kotlin scripting technology to load the policies into Codyze. However, as a Kotlin script can contain any valid Kotlin code, it is also possible to execute arbitrary Kotlin code with Coko. It is currently not possible to prevent this, but all Coko scripts that are available on our website and GitHub repository are validated by us to prevent any misuse. For more information about custom Kotlin scripting languages, please refer to the Kotlin documentation  and the respective Kotlin KEEP .</p> <p>Syntax highlighting and code completion are available for Coko in any IDE that provides these for Kotlin.</p> <p>The syntax of Coko is the same as the syntax of Kotlin. For writing Coko policies you will need to know how to create classes, interfaces and functions in Kotlin. Please refer to the Kotlin Documentation  for an overview.</p>"},{"location":"Coko/#type-safe-builders","title":"Type-safe builders","text":"<p>Coko also uses the concept of type-safe builders . Type-safe builders allow you to build objects in a semi-declarative way similar to markup languages. They can be seen as a special syntax for nesting the construction of objects. They will be explained in detail in the parts of Coko that use them.</p>"},{"location":"Coko/modelling/","title":"Modelling APIs with Coko","text":"<p>To evaluate rules for an API, Coko needs an understanding of the components of the API, such as classes or functions. In Coko these components are modelled through interfaces, classes and a class called <code>Op</code>.</p>"},{"location":"Coko/modelling/#ops","title":"Ops","text":"<p><code>Ops</code>  are the basic building blocks for writing policies in Coko. With <code>Ops</code> you can model and group functions of the API that serve a similar functionality. They are also a way to define queries to the Codyze backend for finding calls to these functions. Each <code>Op</code> object is one query to the backend.</p> <p>There are currently two types of <code>Ops</code>, <code>FunctionOps</code> for modelling functions and <code>ConstructorOps</code> for modelling constructors in object-oriented languages. They are both built with type-safe builders. The following sections will explain the builders for each <code>Op</code> type.</p>"},{"location":"Coko/modelling/#functionops","title":"FunctionOps","text":"<p>The function <code>op()</code>  is the start for building <code>FunctionOps</code>. Within the block of <code>op()</code> the fully qualified name of the functions you want to model can be specified as a string. In the block of the fully qualified name the arguments to function can be defined. They serve as a filter for the query. Only calls to the function with the same number of arguments with the same value at each position will be found by the query.</p> <p>In <code>signature</code> it is also possible to specify unordered arguments. These are arguments, that should somehow be passed to the function calls we want to find, but it is not important, in which position they are passed.</p> Example of defining a FunctionOp<pre><code>op {\n    \"my.fully.qualified.name\" { // (1)!\n        signature(5..10) // (2)!\n        signature(\".*one.*\") // (3)!\n        signature(0..5, listOf(\"one\", \"two\")) // (4)!\n        signature() // (5)!\n    }\n\n    \"my.other.fully.qualified.name\" { // (6)!\n        signature { // (7)!\n            - \".*\" // (8)!\n            -7 // (9)!\n        }\n        signature(arrayOf(4)) { // (10)!\n            - 123\n        }\n    }\n}\n</code></pre> <ol> <li>The fully qualified name of the function we want to find.</li> <li>Filters for calls to <code>my.fully.qualified.name</code> that have as only argument a number between 5 and 10.</li> <li>Filters for calls to <code>my.fully.qualified.name</code> that have a string as only argument that contains \"one\", for example <code>my.fully.qualified.name(\"tone\")</code>.</li> <li>Filters for calls to <code>my.fully.qualified.name</code> that have a number between 0 and 5 as first argument and as second argument either the string \"one\" or \"two\".</li> <li>Filters for calls to <code>my.fully.qualified.name</code> where no arguments were passed.</li> <li>The fully qualified name of the other function we want to find.</li> <li>The <code>signature</code> function can also invoke a type-safe builder.</li> <li>In the type-safe builder of <code>signature</code> the arguments are listed using <code>-</code>.</li> <li>The space after the <code>-</code> is optional.</li> <li>The unordered arguments are given as an array to <code>signature</code>. In this example, the unordered argument is 4.</li> </ol>"},{"location":"Coko/modelling/#constructorops","title":"ConstructorOps","text":"<p>The function of the builder for <code>ConstructorOps</code> is <code>constructor()</code> . The fully qualified name of the class is the first argument. In the block of <code>constructor()</code> you can specify the arguments to the constructor like for the <code>FunctionOp</code>. They serve the same purpose as for <code>FunctionOps</code>.</p> Example of defining a ConstructorOp<pre><code>constructor(\"my.fully.qualified.MyClass\") { // (1)!\n    signature() // (2)!\n}\n</code></pre> <ol> <li>This models the constructor of the class <code>my.fully.qualified.MyClass</code>.</li> <li>The signature is directly specified in <code>ConstructorOps</code>, because the name of the constructor is clear. </li> </ol>"},{"location":"Coko/modelling/#special-argument-types","title":"Special argument types","text":"<p>Arguments in <code>Ops</code> are used to filter calls of a function based on the arguments that are given to the calls. In Coko there are a few special argument types that help with the filtering.</p> <p>The first type is the <code>Wildcard</code> object. If the <code>Wildcard</code> object is given as an argument to <code>Op</code>, the filter will allow any kind of value in the same argument position of the function calls.</p> <p>The second type is <code>null</code>. It can be used to signify that the given arguments should be filtered out of the query. This type will be helpful when constructing <code>Op</code> templates with Coko functions.</p> <p>Another special type are <code>ParameterGroups</code>. They are a filter to express that the argument at the position should be composed of multiple values. An example would be if the argument is a string that should contain multiple strings, for example <code>foo(\"Start string\" + 12 + \"End string\")</code>. This can be modeled with <code>ParameterGroups</code>. Coko offers the DSL function <code>group</code>, in which these values can be specified. </p> <p>The last types are the <code>Type</code> class and the <code>ParamWithType</code> class. The <code>Type</code> class is used to filter the type of the arguments. The fully qualified name of the type must be given <code>ParamWithType</code> combines the filter for the value with the filter for the type.</p> Example with special argument types<pre><code>op {\n    \"my.fully.qualified.name\" {\n        signature(Wildcard) // (1)!\n        signature(Wildcard, 2) // (2)!\n        signature(null, 1) // (3)!\n        signature( \n            group {\n                - \"Start string .*\"\n                - 12\n            } // (4)!\n        )\n        signature(Type(\"java.util.List\")) // (5)!\n        signature(1.0 withType \"java.lang.Float\") // (6)!\n    }\n}\n</code></pre> <ol> <li>Queries for all calls to <code>my.fully.qualified.name</code> that have one argument.</li> <li>Queries for all calls to <code>my.fully.qualified.name</code> with two arguments and where the second argument is 2.</li> <li>Filters out all calls to <code>my.fully.qualified.name</code> with two arguments and where the second argument is 1.</li> <li>Filters for all calls to <code>my.fully.qualified.name</code> with one argument. The argument must contain both <code>\"Start string\"</code> and the number 12. An example would be <code>my.fully.qualified.name(\"Start string with the number \" + 12)</code>.</li> <li>Queries for all calls to <code>my.fully.qualified.name</code> with one argument which must be of type <code>java.util.List</code><sup>1</sup>.</li> <li>Queries for all calls to <code>my.fully.qualified.name</code> with one argument which has the value 1.0 and has the type <code>java.lang.Float</code><sup>1</sup>.</li> </ol>"},{"location":"Coko/modelling/#functions","title":"Functions","text":"<p>Since each <code>Op</code> is interpreted by Codyze as one query for function calls to the backend, it would be helpful to have templates for <code>Ops</code> that find calls to the same function but with different filters. This can be achieved with functions in Coko. The parameters of these functions in Coko can be used to pass the specific values to the filter.</p> An example for an Op template for the function java.util.List.add<pre><code>fun add(\n    element: Any, // (1)!\n    index: Any? // (2)!\n) = op {\n    \"java.util.List.add\" {\n        signature(element)\n        signature(index withType \"int\", element) // (3)!\n    }\n}\n</code></pre> <ol> <li><code>List.add</code> in Java is a generic method, so the type of <code>element</code> is not static. However, it is recommended to use <code>Any</code> even if the type of the value is static since you might want to pass one of the special argument types like <code>Wildcard</code>.</li> <li><code>index</code> is nullable, so it is also possible to filter for calls where no index is given. The type is <code>Any?</code> to be able to pass <code>Wildcard</code> as well. </li> <li>The arguments can be further specified like the additional filter for the type of <code>index</code>.  </li> </ol> <p>If the reference to a Coko function is used for <code>order</code> rules, all parameters must have a nullable type. Coko invokes them with dummy arguments and uses internal functions to query for all calls to the modelled function regardless of the specified signatures. </p>"},{"location":"Coko/modelling/#interfaces","title":"Interfaces","text":"<p>A goal of Coko is to make rules more reusable. Aside from specific rules of an API, there might be some general policies that should be followed for all API that provide similar functionality. An example would be that all actions executed on a database should be logged. Instead of writing the corresponding rule for all combinations of database and logging APIs, one might want to combine this into one reusable rule.</p> <p>This reusability is achieved through interfaces. In Coko interfaces and their functions describe the functionalities that a group of APIs has in common. Rules can thus be written on a more conceptual level.</p> <p>When Coko encounters rules using a Coko interface as a parameter, it will use one of the available classes implementing the interface as argument to evaluate the rule. Currently, it uses the first class it finds, however, we will implement an algorithm in the future which will try to find the implementation that fits the best for the analyzed code.</p> Example of a interface and its implementations in Coko<pre><code>interface Logging {\n    fun log(message: Any?, vararg args: Any?): Op\n}\n\nclass JavaLogging: Logging {\n    override fun log(message: Any?, vararg args: Any?): Op =\n        op {\n            \"java.util.logging.Logger.info\" {\n                signature {\n                    group {\n                        - message\n                        args.forEach { - it }\n                    }\n                }\n            } \n        }\n}\n\nclass PythonLogging: Logging {\n    override fun log(message: Any?, vararg args: Any?): Op =\n        op {\n            \"logging.info\" { \n                signature(args) { // (1)! \n                    - message \n                } \n            }\n        }\n}\n</code></pre> <ol> <li>We don't care about the order of the arguments for <code>args</code>, just that they appear somewhere as arguments for the call.</li> </ol>"},{"location":"Coko/modelling/#classes","title":"Classes","text":"<p>Classes in Coko model the actual components of an API. They can implement interfaces or just be normal classes. With classes, API functions can be grouped</p> <p>For APIs written in object-oriented languages it might be sensible to create a Coko class for each class in the API.</p> <ol> <li> <p>In a real example this would be redundant because this case is already covered by the first filter with <code>Wildcard</code>.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"Coko/rules/","title":"Coko Rules","text":"<p>Rules in Coko describe how an API should be used. They are functions that are annotated with the <code>@Rule</code>  annotation.</p> <p>In the <code>@Rule</code> annotation you can specify metadata about the rule such as the description of the rule. The metadata will be used for describing the findings in the SARIF output.</p> <p>If the rule requires some instance of a model, they can be specified as parameters to the rule function. </p> <p>Each Coko rule must return an implementation of the <code>Evaluator</code>  interface, which Codyze can use to evaluate the rule. Coko provides some common evaluators which will be explained in the following sections. The example model will be used for explaining the evaluators.  </p> Example model<pre><code>class Foo {\n    fun constructor() = constructor(\"Foo\") {\n        signature()\n    }\n\n    fun first(i: Any?) = op {\n        definition(\"Foo.first\") {\n            signature(i)\n        }\n    }\n\n    fun second(s: Any?) = op {\n        definition(\"Foo.second\") {\n            signature(s)\n        }\n    }\n}\n\nclass Bar {\n    fun second() = op {\n        definition(\"Bar.second\") {\n            signature()\n        }\n    }\n}\n</code></pre>"},{"location":"Coko/rules/#only-evaluator","title":"Only Evaluator","text":"<p>The <code>only</code> evaluator checks if all calls to an <code>Op</code> are only called with the specified arguments. Therefore, it takes one <code>Op</code> as argument.</p> Rule example using only<pre><code>@Rule\nfun `only calls to first with 1 allowed`(foo: Foo) = \n    only(foo.first(1))\n</code></pre>"},{"location":"Coko/rules/#order-evaluator","title":"Order Evaluator","text":"<p>The <code>order</code> evaluator checks if functions related to an object are called in the correct order. It takes two arguments, the <code>baseNodes</code> and the order. The <code>baseNodes</code> are the function calls that are the start of the order. Usually, this is either the constructor of a class or some kind of initialization function.</p> <p>To construct the order, Coko provides a type-safe builder. Within the builder, the order is specified as a regular expression.</p> <p>The \"alphabet\" of the order regex is:</p> <ul> <li>references to functions that return an <code>Op</code> written as <code>&lt;object&gt;::&lt;FunctionName&gt;</code> or <code>::&lt;FunctionName&gt;</code></li> <li><code>Ops</code> themselves.</li> </ul> <p>If all calls to a modelled function should be considered for the order regardless of the specified signatures, please use the first option. When passing <code>Ops</code>, only functions that match the used signature and argument are considered valid.</p> <p>The builder provides a set of functions that allow you to add quantifiers to the regex or group them.</p> Function Regex Description <code>or</code> | Represents a choice, either the first or the second expression has to be matched <code>set</code> [] Represents multiple choices, one expression in it has to be matched <code>maybe</code> * Matches an expression zero or more times <code>some</code> + Matches an expression one or more times <code>option</code> ? Matches an expression zero or one time <code>count(n)</code> {<code>n</code>} Matches an expression exactly <code>n</code> times <code>atLeast(min)</code> {<code>min</code>,} Matches an expression at least <code>min</code> times <code>between(min, max)</code> {<code>min</code>, <code>max</code>} Matches an expression at least <code>min</code> and at most <code>max</code> times Rule example using order<pre><code>@Rule\nfun `order of Foo`(foo: Foo) = \n    order(foo.constructor()/* (2)! */) { // (1)!\n        - foo.first(...) // (3)!\n        maybe(foo::second) // (4)!\n    }\n</code></pre> <ol> <li>This starts the type-safe builder for the order.</li> <li>The <code>Op</code> returned from <code>foo.constructor</code> will be used as query for the function calls that are the starting point for evaluating the order.</li> <li>This will use the filtered <code>Op</code> returned by <code>foo.first(...)</code> for the order.</li> <li>This will consider all calls to the function modelled by <code>foo.second()</code> for the order. No filter will be applied. </li> </ol>"},{"location":"Coko/rules/#followedby-evaluator","title":"FollowedBy Evaluator","text":"<p>The <code>followedBy</code> evaluator works similarly like the implication in logic. It takes two <code>Ops</code> and specifies that if the first <code>Op</code> is called then the second <code>Op</code> must be called as well. Compared to the <code>order</code> evaluator, <code>followedBy</code> is more flexible because <code>Ops</code> from different models can be connected.</p> Rule example using followedBy<pre><code>@Rule\nfun `if first then second`(foo: Foo, bar: Bar) = \n    foo.first(Wildcard) followedBy bar.second()\n</code></pre>"},{"location":"Coko/rules/#precedes-evaluator","title":"Precedes Evaluator","text":"<p>The <code>precedes</code> evaluator is the logical counterpart to the <code>followedBy</code> evaluator, implementing a logical reverse implication. Similar to the previous evaluator, it takes two <code>Ops</code>. Whenever the second <code>Op</code> is called, the first <code>Op</code> must have been called before. In contrast to the <code>followedBy</code> evaluator, the second <code>Op</code>acts as the trigger for the rule and no finding is generated when only the first <code>Op</code> is encountered in any given context.</p> Rule example using precedes<pre><code>@Rule\nfun `always first before second`(foo: Foo, bar: Bar) = \n    foo.first(Wildcard) precedes bar.second()\n</code></pre>"},{"location":"Coko/rules/#never-evaluator","title":"Never Evaluator","text":"<p>The <code>never</code> evaluator is used to specify that calls to an <code>Op</code> with the specified arguments are forbidden. It takes one <code>Op</code> as argument.</p> Rule example using never<pre><code>@Rule\nfun `never call second with 1`(foo: Foo) =\n    never(foo.second(1))\n</code></pre>"},{"location":"Coko/rules/#argument-evaluator","title":"Argument Evaluator","text":"<p>The <code>argumentOrigin</code> evaluator is used to trace back the argument of a call to a specific method call. It takes three arguments:  - The target <code>Op</code> whose argument we want to verify  - The position of the argument in question (0-based indexing)  - The origin <code>Op</code> which should have produced the argument</p> <p>The evaluator will then try to check whether the argument of the target <code>Op</code> was always produced by a call to the origin <code>Op</code>. If this is not the case or the Evaluator lacks information to clearly determine the origin of the argument, it will generate a finding.</p> Rule example using argumentOrigin<pre><code>@Rule\nfun `only call Foo::critical with argument produced by Bar::strong`(foo: Foo, bar: Bar) =\n    argumentOrigin(Foo::critical, 0, Bar::strong)\n</code></pre>"},{"location":"Getting%20Started/cli/","title":"Using CLI mode","text":""},{"location":"Getting%20Started/cli/#command-line-mode","title":"Command line mode","text":"<p>When running in command line interface (CLI) mode, Codyze can be used to automatically check a code base against a set of rules given in a supported specification language like Coko. Below are short exemplary calls to start codyze in command line interface mode. <code>./</code> refers to the top-level directory of the repository. However, for the Gradle arguments <code>./</code> refers to the directory of the project, which is <code>codyze-cli</code>.</p> <p><pre><code>./gradlew :codyze-cli:run --args=\"&lt;executor&gt; --spec &lt;specpath&gt; &lt;backend&gt; -s &lt;sourcepath&gt;\"\n</code></pre> Because Codyze is built to be modular and support many specification languages as well as code analysis backends, there are subcommands to select the <code>executor</code>/<code>backend</code>. To find what arguments each <code>executor</code>/<code>backend</code> accept, use the <code>--help</code> argument:</p> <p>To show the available <code>executors</code> use: <pre><code>./gradlew :codyze-cli:run --args=\"--help\"\n</code></pre></p> <p>To show the arguments accepted by an executor and the available <code>backend</code>s use: <pre><code>./gradlew :codyze-cli:run --args=\"&lt;executor&gt; --help\"\n</code></pre></p> <p>To show the arguments accepted by a <code>backend</code> use: <pre><code>./gradlew :codyze-cli:run --args=\"&lt;executor&gt; &lt;backend&gt; --help\"\n</code></pre></p>"},{"location":"Getting%20Started/cli/#analysis-example","title":"Analysis Example","text":"<p>The repository contains examples which you can use to test Codyze. Below are the commands to call Codyze on these examples.</p> <pre><code>./gradlew :codyze-cli:run --args=\"runCoko --spec ../codyze-specification-languages/coko/coko-dsl/src/test/resources/model.codyze.kts --spec ../codyze-specification-languages/coko/coko-dsl/src/test/resources/javaimpl.codyze.kts cokoCpg -s ../codyze-specification-languages/coko/coko-dsl/src/test/resources/java/Main.java\" \n</code></pre> <p>This configures <code>Codyze</code> to use the 'coko' executor and the 'cokoCpg' backend. You will see the result printed to the console and a <code>findings.sarif</code> files is generated in the <code>codyze-cli</code> folder. The spec files contain a single rule, which checks that every change to a database is logged. The sample Java file adheres to the rule, so there should be no issues in the result.</p>"},{"location":"Getting%20Started/cli/#cicd-integration","title":"CI/CD Integration","text":"<p>The CLI mode is a perfect candidate for integration in CI/CD processes, such as GitHub Actions. The following file can be used as an example so set up a compliance check for Java-based applications using GitHub Actions:</p> <pre><code>name: build\n\non:\n  - push\n\nenv:\n  CODYZE_VERSION: \"2.1.1\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-java@v3\n        with:\n          distribution: \"temurin\"\n          java-version: \"17\"\n      - name: Install Codyze\n        run: |\n          wget \"https://github.com/Fraunhofer-AISEC/codyze/releases/download/v${CODYZE_VERSION}/codyze-${CODYZE_VERSION}.zip\" &amp;&amp; unzip codyze-${CODYZE_VERSION}.zip\n      - name: Check compliance\n        run: |\n          codyze-${CODYZE_VERSION}/bin/codyze &lt;arguments&gt;\n</code></pre>"},{"location":"Getting%20Started/configuration/","title":"Configure Codyze","text":"<p>There are two ways of configuring Codyze, through command line options or a configuration file.</p> <p>If both are present, the command line options take precedence over the configuration file.  For list and map type options, the data from the configuration file can be overwritten if the normal option (e.g. <code>--option-name</code>) is used.  To append the data from the command line to the one from the configuration file, use the <code>additions</code> option (e.g. <code>--option-name-additions</code>)</p>"},{"location":"Getting%20Started/configuration/#configuration-file","title":"Configuration File","text":"<p>The configurations can also be defined with a JSON configuration file.  Use the option <code>--config=&lt;filepath&gt;</code> to specify the path to the config file. The configuration from <code>./codyze.json</code> will always be loaded if no other file is specified.</p> <p>Relative paths in the configuration file are resolved relative to the configuration file location.</p> <p>The configuration structure separates the options by subcommand as seen below. <pre><code>{\n  \"good-findings\": false,\n  \"runCoko\": {\n    \"spec\": \"./model.codyze.kts\",\n    \"cokoCpg\": {\n      \"source\": \"./Main.java\"\n    }\n  }\n}\n</code></pre> In this example the <code>good-findings</code> argument belongs to Codyze, the <code>spec</code> argument belongs to the <code>runCoko</code> subcommand and the <code>source</code> argument belongs to the <code>cokoCpg</code> subcommand. The value of the option is taken from the object which corresponds to the subcommand used for the execution.</p> <p>It is important to note that the configuration file only sets the options for each subcommand but does not invoke the subcommand itself. A complete usage example for using a configuration file in combination with subcommands looks as follows: <pre><code>./gradlew :codyze-cli:run --args=\"--config=config.json runCoko cokoCpg\"\n</code></pre> Mind that the config file must be specified as a top-level argument before calling the respective subcommands for the <code>executor</code> or <code>backend</code>.</p> <p>An exemplary configuration file can also be found in the GitHub repository .</p>"},{"location":"Getting%20Started/configuration/#list-of-configurations","title":"List of Configurations","text":"<p>This is a list of all available configurations, their descriptions and their respective name. The names are the same for the configuration file and the CLI options.</p> <p><code>./</code> denotes the working directory in which Codyze was started.</p>"},{"location":"Getting%20Started/configuration/#codyze","title":"Codyze","text":"Key Value Description Default Value output Path The path to write the results file to. <code>[./]</code> output-format String Format in which the analysis results are returned. <code>sarif</code> good-findings Boolean Enable/Disable output of \"positive\" findings which indicate correct implementations. <code>true</code> pedantic Boolean Activates pedantic analysis mode. In this mode, Codyze analyzes all given specification files and report all findings. <code>false</code>"},{"location":"Getting%20Started/configuration/#executors","title":"Executors","text":""},{"location":"Getting%20Started/configuration/#coko","title":"Coko","text":"Key Value Description Default Value spec Path[] Paths to CoKo rule files. <code>[./]</code> disabled-specs Path[] The specified files will be excluded from being parsed and processed. <code>[]</code> disabled-spec-rules String[] Rules that will be ignored by the analysis. <code>[]</code>"},{"location":"Getting%20Started/configuration/#backends","title":"Backends","text":""},{"location":"Getting%20Started/configuration/#cpg","title":"Cpg","text":"Key Value Description Default Value source Path[] Path to the to be analyzed files or directories. <code>[./]</code> disabled-source Path[] Path to files or directories which should not be analyzed. Symbolic links are not followed when filtering out these paths. <code>[]</code> additional-language String[] Specify programming languages of files to be analyzed (full names). <code>[]</code> unity boolean Only relevant for C++. A unity build refers to a build that consolidates all translation units into a single one, which has the advantage that header files are only processed once, adding far less duplicate nodes to the graph. false type-system-in-frontend boolean If false, the type listener system is only activated once the frontends are done building the initial AST structure. This avoids errors where the type of a node may depend on the order in which the source files have been parsed. true default-passes boolean Adds all default passes in cpg (1. FilenameMapper, 2. TypeHierarchyResolver, 3. ImportResolver, 4. VariableUsageResolver, 5. CallResolver, 6. EvaluationOrderGraphPass, 7. TypeResolver). true passes String[] Register these passes to be executed in the specified order. Please specify the passes with their fully qualified name. <code>[]</code> debug-parser boolean Enables debug output generation for the cpg parser. false disable-cleanup boolean Switch off cleaning up TypeManager memory after analysis, set to true only for testing. false code-in-nodes boolean Should the code of a node be shown as parameter in the node. false annotations boolean Enables processing annotations or annotation-like elements. false fail-on-error boolean Should parser/translation fail on parse/resolving errors (true) or try to continue in a best-effort manner (false). false symbols Map Definition of additional symbols. <code>{}</code> parallel-frontends boolean If true, the ASTs for the source files are parsed in parallel, but the passes afterwards will still run in a single thread. This speeds up initial parsing but makes sure that further graph enrichment algorithms remain correct. false match-comments-to-nodes boolean Controls whether the CPG frontend shall use a heuristic matching of comments found in the source file to match them to the closest AST node and save it in the comment property. false analyze-includes boolean Enables parsing of include files. If includePaths are given, the parser will resolve symbols/templates from these in include but not load their parse tree. false includes Path[] Paths containing include files. <code>[]</code> enabled-includes Path[] If includes is not empty, only the specified files will be parsed and processed in the cpg, unless it is a part of the disabled list, in which it will be ignored. <code>[]</code> disabled-includes Path[] If includes is not empty, the specified includes files will be excluded from being parsed and processed in the cpg. The disabled list entries always take priority over the enabled list entries. <code>[]</code>"},{"location":"Getting%20Started/installation/","title":"Install Codyze","text":""},{"location":"Getting%20Started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17 or higher</li> </ul>"},{"location":"Getting%20Started/installation/#build-from-source","title":"Build from Source","text":"<p>Clone the source code for Codyze from the project's GitHub repository .</p>"},{"location":"Getting%20Started/installation/#codyze-v3","title":"Codyze v3","text":""},{"location":"Getting%20Started/installation/#executable-version","title":"Executable Version","text":"<ul> <li>To build an executable version, run <code>./gradlew :codyze-cli:installDist</code></li> <li>The executable Codyze installation is located under <code>codyze-cli/build/install/codyze-cli</code></li> </ul>"},{"location":"Getting%20Started/installation/#gradle-run-task","title":"Gradle Run Task","text":"<p>You can also use the Gradle run task <code>./gradlew :codyze-cli:run</code> to directly run Codyze. This will print the help message and return an error.</p> <p>Arguments can be passed with the <code>--args</code> option.</p>"},{"location":"Getting%20Started/installation/#pre-built-release","title":"Pre-built Release","text":"<p>Note</p> <p>All following example calls in this documentation will assume that the source code was cloned and use the exact file structure. If you want to test Codyze with these calls, please clone the repository.</p> <ul> <li>Download a zipped release of Codyze from our GitHub release page </li> <li>Unzip the file</li> <li>Execute Codyze using <code>bin\\codyze.bat</code> (Windows) or <code>bin/codyze</code> (Mac, Linux)</li> </ul>"},{"location":"Getting%20Started/installation/#docker","title":"Docker","text":"<p>We're also offering Codyze as a container image. You can find an image with the latest release in the project's container registry .</p>"},{"location":"Getting%20Started/lsp/","title":"Using plugins","text":"<p>Codyze can be integrated into multiple IDEs to automatically scan your code for errors.</p>"},{"location":"Getting%20Started/lsp/#integration-in-eclipse","title":"Integration in Eclipse","text":"<p>The Codyze plugin can be installed from an Eclipse update site. It has been tested against Eclipse 2019-12 and later.</p> <ol> <li>In Eclipse, click on <code>Help</code>-&gt;<code>Install New Software...</code></li> <li>Click <code>Add...</code> to add a new update site</li> <li> <p>Choose a name and enter the location https://codyze.s3.eu-central-1.amazonaws.com/codyze-eclipse-plugin/ (note that this is an Eclipse update site URL and not suited to open with a web browser)</p> <p> </p> </li> <li> <p>Choose and install <code>Codyze Code Analyzer</code></p> <p> </p> </li> </ol> <p>Once installed, configure the Eclipse plugin to use the local LSP server:</p> <ol> <li> <p>Go to Windows-&gt;Preferences-&gt;Codyze Code Analysis and configure the path to the analysis server binary</p> <p> </p> </li> <li> <p>If the configuration is correct, <code>.java</code> and <code>.cpp</code> files will be automatically scanned when they are saved. Any errors found by Codyze will be highlighted as problems. If Codyze verifies that an API is correctly used, it will mark the line with a hint.</p> <p> </p> </li> </ol>"},{"location":"Getting%20Started/lsp/#integration-in-intellij","title":"Integration in IntelliJ","text":"<ol> <li>Download and install the <code>LSP Support</code> plugin. Restart IntelliJ.</li> <li>Go to <code>Settings</code> -&gt; <code>Language Server Protocol</code> -&gt; <code>Server Definitions</code></li> <li> <p>Add a new server definition of type <code>Executable</code> for extension <code>java</code> and navigate to your local <code>codyze-&lt;version&gt;/bin/codyze</code> script. </p> <p> </p> </li> </ol> <p>If everything works as intended, you should see a green circle in your IntelliJ status bar, indicating that the connection to the language server was successful.</p>"},{"location":"Getting%20Started/lsp/#integration-in-visual-studio-2019","title":"Integration in Visual Studio 2019","text":"<p>The Codyze plugin can be installed from the Visual Studio 2019 Marketplace</p> <p> </p> <p>If you prefer installing the plugin from the release page, proceed as follows:</p> <ol> <li>Download the zipped extension from the release page</li> <li>Unzip the file</li> <li>Double-click the VSIX-file to install the extension</li> <li>Launch Visual Studio</li> </ol> <p>On startup, the plugin will ask you for the path to Codyze and to the mark files you want to use. If everythings checks out, the plugin will automatically start an instance of Codyze when a solution is opened. It will then scan <code>.cpp</code> files when opened or saved and highlight potential problems.</p> <p>To adjust the path to Codyze, the mark files or change the command line arguments used for Codyze, in Visual Studio go to <code>Tools</code> -&gt; <code>Options...</code> -&gt; <code>Codyze Plugin</code> -&gt; <code>Codyze Settings</code>.</p>"},{"location":"Getting%20Started/lsp/#integration-in-visual-studio-code","title":"Integration in Visual Studio Code","text":"<p>We build a Visual Studio Code plugin of Codyze for every new version. You can download a bundled <code>*.vsix</code> plugin from the release page of Codyze .</p>"},{"location":"Getting%20Started/lsp/#integration-through-lsp-mode","title":"Integration through LSP mode","text":"<p>Codyze offers an LSP mode. You can user the LSP mode to integrate Codyze into any IDE or text editor with support for LSP. You need to look up the recommended approach for your favorite IDE or text editor.</p> <p>Once you know, how to configure an LSP tool, you need to start Codyze in LSP mode, i.e. <code>codyze-v2 -l</code> in Codyze v2 or <code>codyze lsp</code> in Codyze v3. Please refer to the configuration page.</p>"},{"location":"Plugins/","title":"Plugin Overview","text":"<p>Experimental</p> <p>This feature is disabled by default and has to be manually enabled in the gradle.properties file before building.</p> <p>There are many code analysis tools available, and they frequently yield a wide range of different results. However, finding and configuring the correct tools for your projects is time-consuming and distributes the results into separate report files. Plugins are designed to make adding new tools easier and to allow for quickly swapping preferred analysis methods.</p>"},{"location":"Plugins/#what-are-plugins","title":"What are Plugins?","text":"<p>Plugins are - as the name suggests - modular analysis additions that run other open-source tools. Since those tools are independent of each other, the same finding may occur multiple times if they are reported by more than one tool.</p> <p>By default, Codyze creates a single consolidated report for all analysis runs by combining the reports generated by the plugins into its primary output file. This behaviour can be toggled in the configuration of each plugin.</p>"},{"location":"Plugins/#configuration-options","title":"Configuration Options","text":"<p>Each plugin can be configured through the following options:</p> Key Value Description Mandatory target Path[] The target file to be analyzed by the plugin Yes context Path[] Additional plugin-dependent context (Yes/No) separate/combined Boolean Whether the plugin report should be standalone No output File The location of the plugin report. No <p>The <code>context</code> adds a way of giving additional information to a plugin that may be necessary to complete the analysis. Therefore, the specific plugin defines whether this option is necessary, optional or ignored.</p> <p>The default result format is a <code>combined</code> report file. In this case, the <code>output</code> option is ignored</p>"},{"location":"Plugins/#available-plugins","title":"Available Plugins","text":"<p>Note</p> <p>The list of available plugins may expand in future updates.</p> Name Version Source Website Analysis Target PMD 7.2.0 GitHub github.io Source Code FindSecBugs  (SpotBugs) 1.12.0  4.8.2 GitHub GitHub github.io github.io Compiled Java Code"},{"location":"Plugins/FindSecBugs/","title":"FindSecBugs Plugin","text":"<p>Info</p> <p>Check out the official site here.</p>"},{"location":"Plugins/FindSecBugs/#plugin-overview","title":"Plugin overview","text":"<p>FindSecBugs is an extension of the SpotBugs analyzer that works on compiled Java code. It focuses on finding security-critical bugs such as potential code injections.</p> <p>Bug</p> <p>Using the FindSecBugs plugin may mark the analysis run as unsuccessful when using lambdas. This is a known issue within SpotBugs</p> <p>How does FindSecBugs use the context?</p> <p>FindSecBugs relies on the compiled code of the libraries to resolve all code references. Therefore, the context should point to those libraries in order to ensure a complete analysis.</p>"},{"location":"Plugins/PMD/","title":"PMD Plugin","text":"<p>Info</p> <p>Check out the official site here.</p>"},{"location":"Plugins/PMD/#plugin-overview","title":"Plugin overview","text":"<p>PMD is a source code analyzer that searches for common programming flaws. It supports many different languages and can be extended by different sets of rules.</p> <p>In its current implementation the plugin uses the following sets of rules:</p> <ul> <li>all-java.xml (link)</li> </ul> <p>Note</p> <p>These rules define the supported languages as well as the flaws found in those languages. They may be extended in future updates.</p> <p>How does PMD use the context?</p> <p>PMD does not rely on additional context, this option is therefore ignored.</p>"},{"location":"contributors/","title":"Contributing to Codyze","text":"<p>Codyze is open source and an ongoing effort to support developers and auditors in improving the quality of security-critical code.  We welcome everybody to contribute to this project, be it fixing a typo in the documentation or implementing whole new language support and analysis modules.</p> <p>Note</p> <p>Please note that parts of this Codyze are backed by research projects.  If you plan to make larger contributions, please contact us upfront to align your plans with possibly ongoing projects.</p>"},{"location":"contributors/#contributing-to-this-documentation","title":"Contributing to this documentation","text":"<p>This documentation lives in the same repository as the code and the idea is that both are always consistent.  If you make changes in the code that affect the documentation, please update the documentation in the same pull request.</p> <p>We use MkDocs  for generating our documentation site and Material for MkDocs  as our theme.  </p> <p>To extend or fix errors in this documentation, proceed as follows:</p> <ol> <li>Fork the Codyze repo  on GitHub.</li> <li>Make your changes and send a pull request (PR).</li> <li>If you're not yet ready for a review, add \"WIP\" to the PR name to indicate    it's a work in progress.</li> <li>Continue updating your doc and pushing your changes until you're happy with    the content.</li> <li>When you're ready for a review, add a comment to the PR, and remove any   \"WIP\" markers.</li> </ol>"},{"location":"contributors/#previewing-your-changes-locally","title":"Previewing your changes locally","text":"<p>If you want to run your own local server to preview your changes as you work, you can either install MkDocs or use a docker.</p> <p>For installing MkDocs, please refer to the Material for MkDocs documentation .</p> <p>For the docker, please refer to the README .</p>"},{"location":"contributors/#creating-an-issue","title":"Creating an issue","text":"<p>If you've found a problem in the docs, but you're not sure how to fix it yourself, please create an issue in the Codyze repo  and add the label <code>documentation</code> to it. You can also create an issue about a specific page by clicking the Create Issue button in the top right hand corner of the page.</p>"},{"location":"contributors/#contributing-to-codyze","title":"Contributing to Codyze","text":""},{"location":"contributors/#opening-an-issue","title":"Opening an issue","text":"<p>We welcome any bug reports! Please use the issue tracker only to report bugs or unexpected behavior. If you have general questions about the project or need help in setting it up, please reach out to us directly and do not the issue tracker.</p> <p>To report a bug, make sure to include the following information:</p> <ol> <li>What have you done? Provide the minimal set of files needed to reproduce the bug. If we cannot reproduce it, it's not a bug.</li> <li>What outcome have you expected, what outcome did you get?</li> <li>Can you provide any hints on what might be the cause of the bug and how you think it should be fixed?</li> </ol>"},{"location":"contributors/#useful-resources","title":"Useful resources","text":"<ul> <li>Material for MkDocs user guide : All about Material, the documentation template we use, including how it manages navigation, look and feel, and multi-language support.</li> <li>MkDocs user guide : Comprehensive reference for MkDocs.</li> <li>GitHub Hello World! : A basic introduction to GitHub concepts and workflow.</li> </ul>"},{"location":"contributors/CONTRIBUTING/","title":"How to Contribute?","text":"<p>We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.</p>"},{"location":"contributors/CONTRIBUTING/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution; this simply gives us permission to use and redistribute your contributions as part of the project. Head over to here  to see your current agreements on file or to sign a new one.</p> <p>You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.</p>"},{"location":"contributors/CONTRIBUTING/#code-reviews","title":"Code reviews","text":"<p>All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help  for more information on using pull requests.</p>"},{"location":"contributors/CONTRIBUTING/#community-guidelines","title":"Community Guidelines","text":"<p>This project follows Google's Open Source Community Guidelines .</p>"},{"location":"contributors/code/","title":"Build the project","text":""},{"location":"contributors/code/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java SE 17 or later</li> </ul>"},{"location":"contributors/code/#check-out-build-and-extend-codyze","title":"Check out, build, and extend Codyze","text":"<ol> <li>Fork the Codyze repo  on GitHub and clone it:<code>git clone git://github.com/&lt;YOUR GITHUB&gt;/codyze</code></li> <li>Create a branch for your contribution. We recommend prefixing the branch name with <code>fix-</code> if you are providing a bug fix or <code>feature-</code> if you plan to add a feature:<code>git checkout -b feature-MY_EPIC_FEATURE</code></li> <li>Make your changes and make sure that the project builds without errors, passes all tests, and is properly formatted: <code>./gradlew :codyze-cli:clean :codyze-cli:spotlessApply :codyze-cli:build :codyze-cli:installDist</code> The purpose of these gradle tasks is as follows:<ul> <li>clean Removes previous build artifacts</li> <li>spotlessApply Applies source code formatting with the settings in <code>formatter-settings.xml</code>. If the code is not properly formatted the build server will reject it.</li> <li>build Builds the main artifact (the jar file containing Codyze)</li> <li>installDist Create an executable script for Linux, Mac, and Windows in <code>codyze-cli/build/install/codyze-cli/bin</code></li> </ul> </li> <li>When everything works, <code>git commit</code> your changes and <code>git push</code> them to GitHub, then create a pull request (PR). Make sure to describe want you intend the code to do and refer to any issues your PR might address (using the notation <code>#123</code>)</li> <li>If you're not yet ready for a review, add \"WIP\" to the PR name to indicate it's a work in progress.</li> <li>Wait for the automated CI workflow to do some checks.</li> <li>Continue working on your PR by pushing further commits to your branch until you are satisfied</li> <li>When you're ready for a review, add a comment to the PR, and remove any \"WIP\" markers.</li> </ol>"},{"location":"contributors/code/#code-formatting","title":"Code formatting","text":"<p>Codyze uses the gradle spotless plugin to format source code. You may import the code style definitions into your favorite IDE to apply it immediately.</p>"},{"location":"contributors/code/#gradle","title":"Gradle","text":"<ul> <li>Simply run <code>./gradlew :codyze-cli:spotlessApply</code></li> </ul>"},{"location":"contributors/code/#ides","title":"IDEs","text":"<p>You may find plugins for your favorite IDE that can execute Spotless within your IDE for you.  Please refer to your respective IDE.</p>"}]}