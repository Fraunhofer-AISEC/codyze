package botan


/*
 * From Botan Handbook:
 * "In general a bare block cipher is not what you should be using. You probably want a cipher mode instead (see Cipher Modes)"
 */

entity Botan.Cipher_Mode {
	
	var algorithm;
	var symkey : Botan.SymmetricKey; 
	var iv : Botan.InitializationVector;
	var iv_length;
	var direction;

	var input;
	var input_length;
	
	var inout;
	
	var aead_data;
	var aead_data_len;

	/* 
		Note: allows creating objects of Type Botan::Keyed_Filter and Botan::Cipher_Mode, therefore all other ops should consider member functions of these two classes 

		Botan::OctetString might be allowed for key and IV, but we will not accept it because Botan::SymmetricKey and Botan::InitializationVector carry more semantics, which should increase safety and maintainability.
		We allow secure vector because real world examples seem to use it
		*/

	op create_uninit {
		Botan::get_cipher_mode(algorithm, direction, ...);
		Botan::get_cipher(algorithm, direction);
	}
	
	op create_key_init {
		Botan::get_cipher(
			algorithm, 
			iv: Botan::InitializationVector, 
			direction
		);
	}
	
	op create_key_iv_init {
		Botan::get_cipher(
			algorithm, 
			symkey: Botan::SymmetricKey, 
			iv: Botan::InitializationVector, 
			direction
		);
	}

	op set_key {
		Botan::Cipher_Mode::set_key(symkey: Botan::SymmetricKey | Botan::secure_vector<uint8_t>);
		forbidden Botan::Cipher_Mode::set_key(_, _);
		Botan::Keyed_Filter::set_key(symkey: Botan::SymmetricKey | Botan::secure_vector<uint8_t>);
	}
	
	op set_iv {
		Botan::Keyed_Filter::set_iv(iv: Botan::InitializationVector);
	}

	op start_no_iv {
		Botan::Cipher_Mode::start();
		Botan::Keyed_Filter::start_msg();
	}
	
	op start_iv {
		Botan::Cipher_Mode::start(iv);
		Botan::Cipher_Mode::start(iv, iv_length);
		Botan::Cipher_Mode::start_msg(iv, iv_length);
	}

	op process {
		Botan::Cipher_Mode::process(input, input_length);
		Botan::Cipher_Mode::update(inout);
		Botan::Cipher_Mode::update(inout, _);

		Botan::Keyed_Filter::write(input, input_length);
	}

	op finish {
		Botan::Cipher_Mode::finish(inout);
		Botan::Cipher_Mode::finish(inout, _);

		Botan::Keyed_Filter::end_msg();
	}

	op reset {
		Botan::Cipher_Mode::reset();
	}
	
	op assoc_data {
		Botan::AEAD_Filter::set_associated_data(aead_data, aead_data_len);
	}
	
}


rule Order {
	// using Botan.Cipher_Mode as cm TODO MARK: allow fq-names for MARK entities
    using Botan.Cipher_Mode as cm
	ensure order cm.a() //TODO order
	onfail WrongOrder
}

rule _2_1_01_Modes {
	using Botan.Cipher_Mode as cm
	ensure
		_split(cm.algorithm, "/", 1) in ["CCM", "GCM", "CBC", "CTR"]
	onfail WrongMode
}

rule BlockCiphers {
	using Botan.Cipher_Mode as cm
	ensure
		(_split(cm.algorithm, "/", 0) == "AES")
		|| (_split(_split(cm.algorithm, "/", 0), "-", 0) == "AES")
	onfail WrongBlockCipher
}

rule UseOfPipe {
	using Botan.Cipher_Mode as cm,
		Botan.Pipe as p
	ensure
		_receives_value_from(p.filter, cm) ||
		cm in p.filterList
	onfail WrongUseOfBotan_CipherMode
}


rule KeyLength {
	using Botan.Cipher_Mode as cm,
		Botan.SymmetricKey as sk
	ensure
		cm.symkey.length in [16, 24, 32]  // 128, 192, 256 bit
	onfail BadKeyLength
}

rule CBCRandomIV  {
	using Botan.Cipher_Mode as cm,
		Botan.RNG as rng
	when 
		_split(cm.algorithm, "/", 1) == "CBC" 
		&& cm.direction == Botan::Cipher_Dir::ENCRYPTION   //TODO Mark/CPG: evaluate enums?
	ensure
		_receives_value_from(cm.iv, rng.random_data)
	onfail NoRandomIV	
}

rule NonRepeatedIV {
/* Initialisierungsvektoren dürfen sich innerhalb einer Schlüsselwechselperiode nicht wiederholen
	wird erreicht in dem wir versichern, dass der Wert des IV direkt aus rng.random_data kommt, da das bedeutet, dass damit neue Zufallszahlen generiert werden
	TODO: ist das wirklich aussreichend?
*/
	using Botan.Cipher_Mode as cm,
		Botan.RNG as rng
	when _split(cm.algorithm, "/", 1) in ["CCM", "GCM"]
	ensure
		_receives_value_directly_from(cm.iv, rng.random_data)
	onfail RepeatedIV 
}

rule IVLengthGCM {
// TODO: Die für den Authentisierungsmechanismus verwendeten Noncen sollen genau 96 Bit lang sein.
	using Botan.Cipher_Mode as cm
	when _split(cm.algorithm, "/", 1) == "GCM"
	ensure
		1 == 1
	onfail WrongIVLengthGCM
}