package bsi.tr_02102_1

/**
 * 
 * 
 * BouncyCastle/JCA uses underscore in the security standard names.
 */
rule ID_2_01 {
	using
        Cipher as c
    ensure
    	/* BSI TR-02102-1, ID 2.01  */
        _split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"] /* don't allow plain `AES`, because it is unclear which one it maps to */
        || _split(c.transform, "/", 0) in ["RSA"]
    onfail
        Invalid_TR21021_Cipher
}

/**
 * 
 */
rule ID_2_1_01 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    ensure
    	/* BSI TR-02102-1, ID 2.1.01 */
        _split(c.transform, "/", 1) in ["CCM", "GCM", "CBC", "CTR"]
    onfail
        InvalidCipherModeforAESBlockCipher
}

/**
 * TODO non-repeated IV, independent vector for encryption and authentication
 */
rule ID_2_1_2_1_01 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["CCM"]
    ensure
    	false // TODO - only bouncycastle; how implemented?
    onfail
        InvalidCCMIV
}

/**
 * TODO tag length
 */
rule ID_2_1_2_1_02 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["CCM"]
    ensure
    	false // TODO - only bouncycastle; how implemented?
    onfail
        InsufficientCCMTagLength
}


/**
 * TODO non-repeated IV, independent vector for encryption and authentication
 */
rule ID_2_1_2_2_01 {
    using
        Cipher as c,
        GCMParameterSpec as gcm
    when
    	/* Allowed block cipher in CCM cipher mode */
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["GCM"]
    ensure
    	false // TODO IV
    onfail
        InvalidGCMIV
}

/**
 * 
 */
rule ID_2_1_2_2_02 {
    using
        Cipher as c,
        GCMParameterSpec as gcm
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["GCM"]
    ensure
    	_is_instance(c.paramspec, "javax.crypto.spec.GCMParameterSpec")
    	&& _is(c.paramspec, gcm) /* Now, c.paramspec should become become another MARK entity */
    	&& (
    		_length(gcm.src) == 12 /* in bytes */
    		|| gcm.len == 12
    		)
    onfail
        InvalidGCMAuthtenticationNonce
}

/**
 * 
 */
rule ID_2_1_2_2_03 {
    using
        Cipher as c,
        GCMParameterSpec as gcm
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["GCM"]
    ensure
    	_is_instance(c.paramspec, "javax.crypto.spec.GCMParameterSpec")
    	&& _becomes(c.paramspec, gcm) /* Now, c.paramspec should become become another MARK entity */
    	&& gcm.tLen >= 96 /* apparently, there are fixed sizes 96, 104, 112, 120 and 128 */
    onfail
        InsufficientGCMTagLength
}


/**
 * 
 */
rule ID_2_1_2_3_01 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["CBC"]
    ensure
    	false // TODO unpredictable IV 
    onfail
        InvalidCBCIV
}

/**
 * 
 */
rule ID_2_1_3_01 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["CBC"]
    ensure
    	_split(c.transform, "/", 2) in ["Foobar"] // TODO matching paddings between Java and TR 
    onfail
        InvalidCBCPadding
}


/**
 * 
 */
rule ID_2_1_2_4_01 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["CTR"]
    ensure
    	false // TODO non-repeating counter for same key  
    onfail
        InvalidCBCPadding
}



/**
 * TODO how is the integrity protected with stream ciphers?
 */
rule ID_2_2_01 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in [""] // TODO possible modes to get a stream cipher?
    ensure
    	false // TODO protect integrity!
    onfail
        InvalidCBCPadding
}

/**
 * TODO use MAC and verify MAC
 */
rule ID_2_2_02 {
    using
        Cipher as c
    when
    	_split(c.transform, "/", 0) in ["AES_128", "AES_192", "AES_256"]
    	&& _split(c.transform, "/", 1) in ["CTR"]
    ensure
    	false // TODO need a MAC here!
    onfail
        InvalidCBCPadding
}


/**
 * TODO ECIES supplied by bouncycastle 
 */
rule ID_3_3_01 {
	using
		Cipher as c
	when
		false
	ensure
		false
	onfail
		InvalidECIESOperationOrder
}

/**
 * TODO ECIES supplied by bouncycastle 
 */
rule ID_3_3_02 {
	using
		Cipher as c
	when
		false
	ensure
		false
	onfail
		InvalidECIESCurveParameter
}

/**
 * TODO ECIES supplied by bouncycastle 
 */
rule ID_3_3_03 {
	using
		Cipher as c
	when
		false
	ensure
		false
	onfail
		InvalidECIESSymmetricKeyDerivation
}

/**
 * TODO ECIES supplied by bouncycastle 
 */
rule ID_3_3_04 {
	using
		Cipher as c
	when
		false
	ensure
		false
	onfail
		InsufficientECIESBasePointOrder
}

/**
 * TODO DLIES
 */



/**
 * RSA with EME-OAEP encoding method
 */
rule ID_3_5_01 {
	using
		Cipher as c
	when
		_split(c.transform, "/", 0) == "RSA"
		&& (
			c.opmode == "javax.crypto.Cipher.ENCRYPT_MODE"
			|| c.opmode == "javax.crypto.Cipher.DECRYPT_MODE"
			)
	ensure
		_split(c.transform, "/", 2) in [
				// "OAEPWITHSHA1ANDMGF1PADDING", "OAEPWITHSHA-1ANDMGF1PADDING" // recommended by referenced RFC 8017, but not a recommended hash function by BSI
				// "OAEPWITHSHA224ANDMGF1PADDING", "OAEPWITHSHA-224ANDMGF1PADDING", // recommended by referenced RFC 8017, but not a recommended hash function by BSI
				"OAEPWITHSHA256ANDMGF1PADDING", "OAEPWITHSHA-256ANDMGF1PADDING",
				"OAEPWITHSHA384ANDMGF1PlADDING", "OAEPWITHSHA-384ANDMGF1PADDING",
				"OAEPWITHSHA512ANDMGF1PADDING", "OAEPWITHSHA-512ANDMGF1PADDING"//,
				// "OAEPWITHSHA3-256ANDMGF1PADDING", // not listed by referenced RFC 8017, but recommended hash function by BSI
				// "OAEPWITHSHA3-384ANDMGF1PADDING", // not listed by referenced RFC 8017, but recommended hash function by BSI
				// "OAEPWITHSHA3-512ANDMGF1PADDING" // not listed by referenced RFC 8017, but recommended hash function by BSI
			]
	onfail
		InvalidRSAPadding
}

/**
 * RSA key length (length of modulus)
 */
rule ID_3_5_02 {
	using
		Cipher as c,
		RSAPublicKeySpec as pubKey
	when
		_split(c.transform, "/", 0) == "RSA"
		&& c.opmode == "javax.crypto.Cipher.ENCRYPT_MODE"
	ensure
		false // TODO
	onfail
		InsufficientRSAKeylength // FIXME valid until 2022
}




