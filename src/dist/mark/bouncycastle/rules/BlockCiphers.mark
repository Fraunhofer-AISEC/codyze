package bsi.tr21021

/**
 * General rule: We're just checking if one of the allowed block ciphers is used.
 * 
 * BouncyCastle/JCA uses underscore in the security standard names.
 */
rule Cipher {
    using
        Cipher as c
    ensure
        _split(c.transform, "/", 0) in ["AES", "AES_128", "AES_192", "AES_256"] /* valid AES BlockCipher */
        || _split(c.transform, "/", 0) in ["AES", "AES_128", "AES_192", "AES_256"]
    onfail
        Invalid_TR21021_Cipher
}

/**
 * General rule: We're just checking if one of the allowed cipher modes is used.
 */
rule CipherMode {
    using
        Cipher as c
    ensure
        _split(c.transform, "/", 1) in ["CCM", "GCM", "CBC", "CTR"]
    onfail
        Invalid_TR21021_CipherMode
}

/**
 * TODO
 * Special rule: We're checking if a default cipher mode is used that is not allowed.
 */
rule DefaultCipherMode {
    using
        Cipher as c
    when
        _split(c.transform, "/", 1) == "" // TODO how to indicate no value returned/determined
    ensure
        bla
    onfail
        Invalid_TR21021_Default_CipherMode
}


rule Crypt {
    using
        Cipher as c
    when
        _split(c.transform, "/", 1) in ["CBC", "CTR"]
        && (c.opmode == 1 /* javax.crypto.Cipher.ENCRYPT_MODE */
            || c.opmode == 2 /* javax.crypto.Cipher.DECRYPT_MODE */
        )
    ensure
        order c.instantiate(),
            c.init(),
            c.update()*,
            c.finalize()
    onfail
        Invalid_TR21021_Order
}

/**
 * Special rule: Different order when using AEAD with GCM/CCM
 */
rule AEAD_Crypt {
    using
        Cipher as c
    when
        _split(c.transform, "/", 1) in ["CCM", "GCM"]
        && (c.opmode == 1 /* javax.crypto.Cipher.ENCRYPT_MODE */
            || c.opmode == 2 /* javax.crypto.Cipher.DECRYPT_MODE */
        )
    ensure
        order c.instantiate(),
            c.init(),
            c.aad()*, /* optional because only called if actually supplying AAD */
            c.update()*,
            c.finalize()
    onfail
        Invalid_TR21021_Order_AEAD
}

// TODO order rule for key wrap
// TODO order rule for key unwrapping
