package botan

entity Botan::RSA_PrivateKey {

    var key_length : int;

    op init {
        Botan::RSA_PrivateKey(_, key_length);
    }
}

entity Botan::StreamCipher isa Cipher {
	
	var algorithm : std::string;
	var direction : Botan::Cipher_Dir; // an enum of underlying type int
	var provider : std::String;
	
	var symkey : Botan::SymmetricKey; // aka Botan::OctetString; class wrapping Botan::secure_vector<T, secure_allocator<T>>; secure_vector<> scrubs memory on deallocate()
	var svkey : Botan::secure_vector<uint8_t>;
	
	var iv : Botan::InitializationVector; // aka Botan::OctetString; class wrapping Botan::secure_vector<T, secure_allocator<T>>; secure_vector<> scrubs memory on deallocate()
	
	var input : Botan::secure_vector<uint8_t>;
	var input_length : std::size_t;
	
	var buffer : std::uint8_t[];
	
	var nonce : std::uint8_t[];
	var nonce_length : std::size_t;
	
	
	op create {
		/*
		 * method call(s):
		 * - static std::unique_ptr<Cipher_Mode> create(const std::string& algo, Cipher_Dir direction, const std::string& provider = "")
		 * - static std::unique_ptr<Cipher_Mode> create_or_throw(const std::string& algo, Cipher_Dir direction, const std::string& provider = "")
		 * 
		 * function call(s):
		 * - Cipher_Mode* get_cipher_mode(const std::string& algo_spec, Cipher_Dir direction, const std::string& provider = "")
		 */
		Botan::get_cipher_mode(algorithm, direction);
		Botan::get_cipher_mode(algorithm, direction, provider);

		/* this is only for botan version >= 2.6.0 */
		Botan::StreamCipher::create(algorithm);
		Botan::StreamCipher::create(algorithm, direction);
		Botan::StreamCipher::create(algorithm, direction, provider);

	    Botan::CTR_BE::create_or_throw(algorithm)
		Botan::StreamCipher::create_or_throw(algorithm);
		Botan::StreamCipher::create_or_throw(algorithm, direction);
		Botan::StreamCipher::create_or_throw(algorithm, direction, provider);
	}
	
	op init {
		/*
		 * method call(s) inherited from Botan::SymmetricAlgorithm:
		 * - void set_key(const SymmetricKey& key)
		 * - template<typename Alloc>
		 *   void set_key(const std::vector<uint8_t, Alloc>& key)
		 * - void set_key(const uint8_t key[], size_t length);
		 */
		Botan::StreamCipher::set_key(symkey);
		Botan::StreamCipher::set_key(svkey);
		forbidden Botan::Cipher_Mode::set_key(_, _);
	}
	
	op start {
		/* 
		 * method call(s):
		 * - template<typename Alloc>
		 *   void start(const std::vector<uint8_t, Alloc>& nonce)
		 * - void start(const uint8_t nonce[], size_t nonce_len)
		 * - void start()
		 * 
		 * - virtual void start_msg(const uint8_t nonce[], size_t nonce_len) = 0;
		 */
    	forbidden Botan::Cipher_Mode::start();
		Botan::Cipher_Mode::start(iv);
		forbidden Botan::StreamCipher::start(nonce, nonce_length);
		
		forbidden Botan::StreamCipher::start_msg(nonce, nonce_length);
	}
	
	op process {
		/*
		 * method call(s): 
		 * - void update(secure_vector<uint8_t>& buffer, size_t offset = 0)
		 * 
		 * - virtual size_t process(uint8_t msg[], size_t msg_len) = 0;
		 */
		Botan::StreamCipher::process(input, input_length);
		
		Botan::StreamCipher::update(buffer);
		Botan::StreamCipher::update(buffer, _);
	}
	
	op finish {
		/*
		 * method call(s):
		 * - virtual void finish(secure_vector<uint8_t>& final_block, size_t offset = 0) = 0;
		 */
		Botan::StreamCipher::finish(input);
		Botan::StreamCipher::finish(input, _);
	}
	
	op reset {
		/*
		 * method call(s):
		 * - virtual void reset() = 0;
		 */
		Botan::StreamCipher::reset();
	}
	
}


rule StreamCiphers {
	using Botan::StreamCipher as sc
	ensure
		sc.algorithm in [ "CTR(AES-256)" ]
	onfail WrongStreamCipher
}

rule UseOfBotan_StreamMode {
	using Botan::StreamCipher as sc
	ensure
		order sc.create(), sc.init(), (sc.start(), sc.process()*, sc.finish())+, sc.reset()?
	onfail WrongUseOfBotan_StreamCipher
}

rule KeySize {
	using Botan::RSA_PrivateKey as pk
	ensure
		pk.key_length > 4096;
	onfail TooShortPrivateKey
}
